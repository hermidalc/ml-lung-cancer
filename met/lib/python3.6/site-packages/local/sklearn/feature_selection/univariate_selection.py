"""Univariate features selection."""

# Authors: V. Michel, B. Thirion, G. Varoquaux, A. Gramfort, E. Duchesnay.
#          L. Buitinck, A. Joly, L. Hermida
# License: BSD 3 clause

import numpy as np
from sklearn.base import BaseEstimator
from sklearn.utils import as_float_array, check_X_y
from sklearn.utils.validation import check_is_fitted
from sklearn.feature_selection.base import SelectorMixin
from .univariate_scorers import BaseScorer, ANOVAFScorerClassification


def _clean_nans(scores):
    """
    Fixes Issue #1240: NaNs can't be properly compared, so change them to the
    smallest value of scores's dtype. -inf seems to be unreliable.
    """
    # XXX where should this function be called? fit? scoring functions
    # themselves?
    scores = as_float_array(scores, copy=True)
    scores[np.isnan(scores)] = np.finfo(scores.dtype).min
    return scores


######################################################################
# Base classes

class _BaseFilter(BaseEstimator, SelectorMixin):
    """Initialize the univariate feature selection.

    Parameters
    ----------
    scorer : object
        Feature scorer of class BaseScorer
    """

    def __init__(self, scorer):
        self.scorer = scorer

    def fit(self, X, y):
        """Run feature scorer on (X, y) and get the appropriate features.

        Parameters
        ----------
        X : array-like, shape = [n_samples, n_features]
            The training input samples.

        y : array-like, shape = [n_samples]
            The target values (class labels in classification, real numbers in
            regression).

        Returns
        -------
        self : object
            Returns self.
        """
        X, y = check_X_y(X, y, ['csr', 'csc'], multi_output=True)
        self._check_params(X, y)
        self.scorer.fit(X, y)
        self.scores_ = np.asarray(self.scorer.scores_)
        if hasattr(self.scorer, 'pvalues_'):
            self.pvalues_ = np.asarray(self.scorer.pvalues_)
        else:
            self.pvalues_ = None
        return self

    def _check_params(self, X, y):
        if not isinstance(self.scorer, BaseScorer):
            raise ValueError('scorer has to be an instance of BaseScorer')


######################################################################
# Specific filters
######################################################################
class SelectPercentile(_BaseFilter):
    """Select features according to a percentile of the highest scores.

    Read more in the :ref:`User Guide <univariate_feature_selection>`.

    Parameters
    ----------
    scorer : object, default=ANOVAFScorerClassification
        Feature scorer. (see below "See also").
        The default function only works with classification tasks.

    percentile : int, optional, default=10
        Percent of features to keep.

    Attributes
    ----------
    scores_ : array-like, shape=(n_features,)
        Scores of features.

    pvalues_ : array-like, shape=(n_features,)
        p-values of feature scores, None if `scorer` returned only scores.

    Notes
    -----
    Ties between features with equal scores will be broken in an unspecified
    way.

    See also
    --------
    ANOVAFScorerClassification: ANOVA F-value between label/feature for classification tasks.
    ANOVAFScorerRegression: ANOVA F-value between label/feature for regression tasks.
    Chi2Scorer: Chi-squared stats of non-negative features for classification tasks.
    MutualInfoScorerClassification: Mutual information for a discrete target.
    MutualInfoScorerRegression: Mutual information for a continuous target.
    SelectKBest: Select features based on the k highest scores.
    SelectFpr: Select features based on a false positive rate test.
    SelectFdr: Select features based on an estimated false discovery rate.
    SelectFwe: Select features based on family-wise error rate.
    GenericUnivariateSelect: Univariate feature selector with configurable mode.
    """

    def __init__(self, scorer=ANOVAFScorerClassification(), percentile=10):
        super(SelectPercentile, self).__init__(scorer)
        self.percentile = percentile

    def _check_params(self, X, y):
        if not 0 <= self.percentile <= 100:
            raise ValueError("percentile should be >=0, <=100; got %r"
                             % self.percentile)

    def _get_support_mask(self):
        check_is_fitted(self, 'scores_')

        # Cater for NaNs
        if self.percentile == 100:
            return np.ones(len(self.scores_), dtype=np.bool)
        elif self.percentile == 0:
            return np.zeros(len(self.scores_), dtype=np.bool)

        scores = _clean_nans(self.scores_)
        treshold = stats.scoreatpercentile(scores,
                                           100 - self.percentile)
        mask = scores > treshold
        ties = np.where(scores == treshold)[0]
        if len(ties):
            max_feats = int(len(scores) * self.percentile / 100)
            kept_ties = ties[:max_feats - mask.sum()]
            mask[kept_ties] = True
        return mask


class SelectKBest(_BaseFilter):
    """Select features according to the k highest scores.

    Read more in the :ref:`User Guide <univariate_feature_selection>`.

    Parameters
    ----------
    scorer : object, default=ANOVAFScorerClassification
        Feature scorer. (see below "See also").
        The default function only works with classification tasks.

    k : int or "all", optional, default=10
        Number of top features to select.
        The "all" option bypasses selection, for use in a parameter search.

    Attributes
    ----------
    scores_ : array-like, shape=(n_features,)
        Scores of features.

    pvalues_ : array-like, shape=(n_features,)
        p-values of feature scores, None if `scorer` returned only scores.

    Notes
    -----
    Ties between features with equal scores will be broken in an unspecified
    way.

    See also
    --------
    ANOVAFScorerClassification: ANOVA F-value between label/feature for classification tasks.
    ANOVAFScorerRegression: ANOVA F-value between label/feature for regression tasks.
    Chi2Scorer: Chi-squared stats of non-negative features for classification tasks.
    MutualInfoScorerClassification: Mutual information for a discrete target.
    MutualInfoScorerRegression: Mutual information for a continuous target.
    SelectKBest: Select features based on the k highest scores.
    SelectFpr: Select features based on a false positive rate test.
    SelectFdr: Select features based on an estimated false discovery rate.
    SelectFwe: Select features based on family-wise error rate.
    GenericUnivariateSelect: Univariate feature selector with configurable mode.
    """

    def __init__(self, scorer=ANOVAFScorerClassification(), k=10):
        super(SelectKBest, self).__init__(scorer)
        self.k = k

    def _check_params(self, X, y):
        if not (self.k == "all" or 0 <= self.k <= X.shape[1]):
            raise ValueError("k should be >=0, <= n_features; got %r."
                             "Use k='all' to return all features."
                             % self.k)

    def _get_support_mask(self):
        check_is_fitted(self, 'scores_')

        if self.k == 'all':
            return np.ones(self.scores_.shape, dtype=bool)
        elif self.k == 0:
            return np.zeros(self.scores_.shape, dtype=bool)
        else:
            scores = _clean_nans(self.scores_)
            mask = np.zeros(scores.shape, dtype=bool)

            # Request a stable sort. Mergesort takes more memory (~40MB per
            # megafeature on x86-64).
            mask[np.argsort(scores, kind="mergesort")[-self.k:]] = 1
            return mask


class SelectFpr(_BaseFilter):
    """Filter: Select the pvalues below alpha based on a FPR test.

    FPR test stands for False Positive Rate test. It controls the total
    amount of false detections.

    Read more in the :ref:`User Guide <univariate_feature_selection>`.

    Parameters
    ----------
    scorer : object, default=ANOVAFScorerClassification
        Feature scorer. (see below "See also").
        The default function only works with classification tasks.

    alpha : float, optional
        The highest p-value for features to be kept.

    Attributes
    ----------
    scores_ : array-like, shape=(n_features,)
        Scores of features.

    pvalues_ : array-like, shape=(n_features,)
        p-values of feature scores.

    See also
    --------
    ANOVAFScorerClassification: ANOVA F-value between label/feature for classification tasks.
    ANOVAFScorerRegression: ANOVA F-value between label/feature for regression tasks.
    Chi2Scorer: Chi-squared stats of non-negative features for classification tasks.
    MutualInfoScorerClassification: Mutual information for a discrete target.
    MutualInfoScorerRegression: Mutual information for a continuous target.
    SelectKBest: Select features based on the k highest scores.
    SelectFpr: Select features based on a false positive rate test.
    SelectFdr: Select features based on an estimated false discovery rate.
    SelectFwe: Select features based on family-wise error rate.
    GenericUnivariateSelect: Univariate feature selector with configurable mode.
    """

    def __init__(self, scorer=ANOVAFScorerClassification(), alpha=5e-2):
        super(SelectFpr, self).__init__(scorer)
        self.alpha = alpha

    def _get_support_mask(self):
        check_is_fitted(self, 'scores_')

        return self.pvalues_ < self.alpha


class SelectFdr(_BaseFilter):
    """Filter: Select the p-values for an estimated false discovery rate

    This uses the Benjamini-Hochberg procedure. ``alpha`` is an upper bound
    on the expected false discovery rate.

    Read more in the :ref:`User Guide <univariate_feature_selection>`.

    Parameters
    ----------
    scorer : object, default=ANOVAFScorerClassification
        Feature scorer. (see below "See also").
        The default function only works with classification tasks.

    alpha : float, optional
        The highest uncorrected p-value for features to keep.


    Attributes
    ----------
    scores_ : array-like, shape=(n_features,)
        Scores of features.

    pvalues_ : array-like, shape=(n_features,)
        p-values of feature scores.

    References
    ----------
    https://en.wikipedia.org/wiki/False_discovery_rate

    See also
    --------
    ANOVAFScorerClassification: ANOVA F-value between label/feature for classification tasks.
    ANOVAFScorerRegression: ANOVA F-value between label/feature for regression tasks.
    Chi2Scorer: Chi-squared stats of non-negative features for classification tasks.
    MutualInfoScorerClassification: Mutual information for a discrete target.
    MutualInfoScorerRegression: Mutual information for a continuous target.
    SelectKBest: Select features based on the k highest scores.
    SelectFpr: Select features based on a false positive rate test.
    SelectFdr: Select features based on an estimated false discovery rate.
    SelectFwe: Select features based on family-wise error rate.
    GenericUnivariateSelect: Univariate feature selector with configurable mode.
    """

    def __init__(self, scorer=ANOVAFScorerClassification(), alpha=5e-2):
        super(SelectFdr, self).__init__(scorer)
        self.alpha = alpha

    def _get_support_mask(self):
        check_is_fitted(self, 'scores_')

        n_features = len(self.pvalues_)
        sv = np.sort(self.pvalues_)
        selected = sv[sv <= float(self.alpha) / n_features *
                      np.arange(1, n_features + 1)]
        if selected.size == 0:
            return np.zeros_like(self.pvalues_, dtype=bool)
        return self.pvalues_ <= selected.max()


class SelectFwe(_BaseFilter):
    """Filter: Select the p-values corresponding to Family-wise error rate

    Read more in the :ref:`User Guide <univariate_feature_selection>`.

    Parameters
    ----------
    scorer : object, default=ANOVAFScorerClassification
        Feature scorer. (see below "See also").
        The default function only works with classification tasks.

    alpha : float, optional
        The highest uncorrected p-value for features to keep.

    Attributes
    ----------
    scores_ : array-like, shape=(n_features,)
        Scores of features.

    pvalues_ : array-like, shape=(n_features,)
        p-values of feature scores.

    See also
    --------
    ANOVAFScorerClassification: ANOVA F-value between label/feature for classification tasks.
    ANOVAFScorerRegression: ANOVA F-value between label/feature for regression tasks.
    Chi2Scorer: Chi-squared stats of non-negative features for classification tasks.
    MutualInfoScorerClassification: Mutual information for a discrete target.
    MutualInfoScorerRegression: Mutual information for a continuous target.
    SelectKBest: Select features based on the k highest scores.
    SelectFpr: Select features based on a false positive rate test.
    SelectFdr: Select features based on an estimated false discovery rate.
    SelectFwe: Select features based on family-wise error rate.
    GenericUnivariateSelect: Univariate feature selector with configurable mode.
    """

    def __init__(self, scorer=ANOVAFScorerClassification(), alpha=5e-2):
        super(SelectFwe, self).__init__(scorer)
        self.alpha = alpha

    def _get_support_mask(self):
        check_is_fitted(self, 'scores_')

        return (self.pvalues_ < self.alpha / len(self.pvalues_))


######################################################################
# Generic filter
######################################################################

# TODO this class should fit on either p-values or scores,
# depending on the mode.
class GenericUnivariateSelect(_BaseFilter):
    """Univariate feature selector with configurable strategy.

    Read more in the :ref:`User Guide <univariate_feature_selection>`.

    Parameters
    ----------
    scorer : object, default=ANOVAFScorerClassification
        Feature scorer. (see below "See also").
        The default function only works with classification tasks.

    mode : {'percentile', 'k_best', 'fpr', 'fdr', 'fwe'}
        Feature selection mode.

    param : float or int depending on the feature selection mode
        Parameter of the corresponding mode.

    Attributes
    ----------
    scores_ : array-like, shape=(n_features,)
        Scores of features.

    pvalues_ : array-like, shape=(n_features,)
        p-values of feature scores, None if `scorer` returned scores only.

    See also
    --------
    ANOVAFScorerClassification: ANOVA F-value between label/feature for classification tasks.
    ANOVAFScorerRegression: ANOVA F-value between label/feature for regression tasks.
    Chi2Scorer: Chi-squared stats of non-negative features for classification tasks.
    MutualInfoScorerClassification: Mutual information for a discrete target.
    MutualInfoScorerRegression: Mutual information for a continuous target.
    SelectKBest: Select features based on the k highest scores.
    SelectFpr: Select features based on a false positive rate test.
    SelectFdr: Select features based on an estimated false discovery rate.
    SelectFwe: Select features based on family-wise error rate.
    GenericUnivariateSelect: Univariate feature selector with configurable mode.
    """

    _selection_modes = {'percentile': SelectPercentile,
                        'k_best': SelectKBest,
                        'fpr': SelectFpr,
                        'fdr': SelectFdr,
                        'fwe': SelectFwe}

    def __init__(self, scorer=ANOVAFScorerClassification(), mode='percentile', param=1e-5):
        super(GenericUnivariateSelect, self).__init__(scorer)
        self.mode = mode
        self.param = param

    def _make_selector(self):
        selector = self._selection_modes[self.mode](scorer=self.scorer)

        # Now perform some acrobatics to set the right named parameter in
        # the selector
        possible_params = selector._get_param_names()
        possible_params.remove('scorer')
        selector.set_params(**{possible_params[0]: self.param})

        return selector

    def _check_params(self, X, y):
        if self.mode not in self._selection_modes:
            raise ValueError("The mode passed should be one of %s, %r,"
                             " (type %s) was passed."
                             % (self._selection_modes.keys(), self.mode,
                                type(self.mode)))

        self._make_selector()._check_params(X, y)

    def _get_support_mask(self):
        check_is_fitted(self, 'scores_')

        selector = self._make_selector()
        selector.pvalues_ = self.pvalues_
        selector.scores_ = self.scores_
        return selector._get_support_mask()
